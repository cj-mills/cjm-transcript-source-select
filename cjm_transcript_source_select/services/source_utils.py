"""Source record operations for metadata extraction, grouping, and validation"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/services/source_utils.ipynb.

# %% auto #0
__all__ = ['extract_batch_id', 'extract_model_name', 'group_transcriptions', 'group_transcriptions_by_audio',
           'is_source_selected', 'filter_transcriptions', 'select_all_in_group', 'toggle_source_selection',
           'reorder_item', 'reorder_sources', 'calculate_next_tab', 'check_audio_exists', 'validate_browse_path']

# %% ../../nbs/services/source_utils.ipynb #su-imports
from typing import Any, List, Dict
from pathlib import Path
import json

# %% ../../nbs/services/source_utils.ipynb #su-extract-batch-id
def extract_batch_id(
    metadata: Any  # Metadata dict or JSON string
) -> str:  # Batch ID or "No Batch ID"
    """Extract batch_id from transcription metadata."""
    if not metadata:
        return "No Batch ID"
    
    # Parse JSON string if needed
    if isinstance(metadata, str):
        try:
            metadata = json.loads(metadata)
        except (json.JSONDecodeError, TypeError):
            return "No Batch ID"
    
    batch_id = metadata.get("batch_id", "")
    return batch_id if batch_id else "No Batch ID"

# %% ../../nbs/services/source_utils.ipynb #su-extract-model-name
def extract_model_name(
    metadata: Any  # Metadata dict or JSON string
) -> str:  # Formatted model name for display
    """Extract and format model name from transcription metadata."""
    if not metadata:
        return "Unknown"
    
    # Parse JSON string if needed
    if isinstance(metadata, str):
        try:
            metadata = json.loads(metadata)
        except (json.JSONDecodeError, TypeError):
            return "Unknown"
    
    model = metadata.get("model", "")
    if not model:
        return "Unknown"
    
    # Extract just the model name (after the slash if present)
    # e.g., "mistralai/Voxtral-Mini-3B-2507" -> "Voxtral-Mini-3B-2507"
    if "/" in model:
        model = model.split("/")[-1]
    
    return model

# %% ../../nbs/services/source_utils.ipynb #su-group-transcriptions
def group_transcriptions(
    transcriptions: List[Dict[str, Any]],  # List of transcription records
    group_by: str = "media_path"  # Grouping mode: "media_path" or "batch_id"
) -> Dict[str, List[Dict[str, Any]]]:  # Grouped transcriptions
    """Group transcription records by the specified field."""
    groups = {}
    for t in transcriptions:
        if group_by == "batch_id":
            key = extract_batch_id(t.get("metadata"))
        else:
            # Default to media_path grouping
            key = t.get("media_path", "Unknown")
        
        if key not in groups:
            groups[key] = []
        groups[key].append(t)
    return groups

# %% ../../nbs/services/source_utils.ipynb #su-group-by-audio
def group_transcriptions_by_audio(
    transcriptions: List[Dict[str, Any]]  # List of transcription records
) -> Dict[str, List[Dict[str, Any]]]:  # Grouped by media_path
    """Group transcription records by their source audio file."""
    return group_transcriptions(transcriptions, group_by="media_path")

# %% ../../nbs/services/source_utils.ipynb #su-is-source-selected
def is_source_selected(
    record_id: str,  # Job ID to check
    selected_sources: List[Dict[str, str]]  # List of selected sources
) -> bool:  # True if source is selected
    """Check if a source is in the selected list."""
    return any(s.get("record_id") == record_id for s in selected_sources)

# %% ../../nbs/services/source_utils.ipynb #tg25xqgkaa
def filter_transcriptions(
    transcriptions: List[Dict[str, Any]],  # List of transcription records to filter
    search_text: str,  # Search term for case-insensitive substring matching
) -> List[Dict[str, Any]]:  # Filtered transcription records
    """Filter transcriptions by substring match across record_id, media_path, and text fields."""
    if not search_text or not search_text.strip():
        return transcriptions
    
    search_lower = search_text.lower().strip()
    return [
        t for t in transcriptions
        if (search_lower in t.get("record_id", "").lower() or
            search_lower in t.get("media_path", "").lower() or
            search_lower in t.get("text", "").lower())
    ]

# %% ../../nbs/services/source_utils.ipynb #u78r83i7z6i
def select_all_in_group(
    transcriptions: List[Dict[str, Any]],  # All transcription records
    group_key: str,  # Group key to match against
    grouping_mode: str,  # Grouping mode: "media_path" or "batch_id"
    selected_sources: List[Dict[str, str]],  # Current selections
) -> List[Dict[str, str]]:  # Updated selections with new items appended
    """Add all transcriptions matching a group key to the selection list, skipping duplicates."""
    # Filter transcriptions by group key
    if grouping_mode == "batch_id":
        matching = [t for t in transcriptions if extract_batch_id(t.get("metadata")) == group_key]
    else:
        matching = [t for t in transcriptions if t.get("media_path") == group_key]
    
    # Deduplicate against existing selections
    existing_record_ids = {s.get("record_id") for s in selected_sources}
    result = list(selected_sources)
    for t in matching:
        record_id = t.get("record_id")
        if record_id and record_id not in existing_record_ids:
            result.append({"record_id": record_id, "provider_id": t.get("provider_id", "")})
            existing_record_ids.add(record_id)
    
    return result

# %% ../../nbs/services/source_utils.ipynb #gtja2coiu2n
def toggle_source_selection(
    record_id: str,  # Job ID to toggle
    provider_id: str,  # Plugin name for the source
    selected_sources: List[Dict[str, str]],  # Current selections
) -> List[Dict[str, str]]:  # Updated selections
    """Toggle a source in or out of the selection list."""
    if any(s.get("record_id") == record_id for s in selected_sources):
        return [s for s in selected_sources if s.get("record_id") != record_id]
    else:
        return selected_sources + [{"record_id": record_id, "provider_id": provider_id}]

# %% ../../nbs/services/source_utils.ipynb #gvvdhrgpf6l
def reorder_item(
    selected_sources: List[Dict[str, str]],  # Current selections
    record_id: str,  # Record ID of item to move
    provider_id: str,  # Provider ID of item to move
    direction: str,  # Direction: "up" or "down"
) -> List[Dict[str, str]]:  # Reordered selections
    """Move an item up or down in the selection list by swapping with its neighbor."""
    sources = list(selected_sources)
    current_index = next(
        (i for i, s in enumerate(sources)
         if s.get("record_id") == record_id and s.get("provider_id") == provider_id),
        None
    )
    
    if current_index is None:
        return sources
    
    if direction == "up" and current_index > 0:
        sources[current_index], sources[current_index - 1] = sources[current_index - 1], sources[current_index]
    elif direction == "down" and current_index < len(sources) - 1:
        sources[current_index], sources[current_index + 1] = sources[current_index + 1], sources[current_index]
    
    return sources

# %% ../../nbs/services/source_utils.ipynb #4aes4jtpch1
def reorder_sources(
    selected_sources: List[Dict[str, str]],  # Current selections
    new_order_ids: List[str],  # Job IDs in desired order
) -> List[Dict[str, str]]:  # Reordered selections
    """Reorder sources to match the given job ID order."""
    if not new_order_ids:
        return list(selected_sources)
    
    source_lookup = {s.get("record_id"): s for s in selected_sources}
    reordered = [source_lookup[jid] for jid in new_order_ids if jid in source_lookup]
    
    # Append any sources not in the new order (safety fallback)
    new_order_set = set(new_order_ids)
    for s in selected_sources:
        if s.get("record_id") not in new_order_set:
            reordered.append(s)
    
    return reordered

# %% ../../nbs/services/source_utils.ipynb #4tcys7w8j16
def calculate_next_tab(
    direction: str,  # Direction: "prev", "next", or a direct tab name
    current_tab: str,  # Currently active tab name
    tabs: List[str],  # Available tab names in order
) -> str:  # New active tab name
    """Calculate the next tab based on direction or direct selection."""
    if direction in tabs:
        return direction
    
    current_idx = tabs.index(current_tab) if current_tab in tabs else 0
    if direction == "prev":
        return tabs[(current_idx - 1) % len(tabs)]
    else:
        return tabs[(current_idx + 1) % len(tabs)]

# %% ../../nbs/services/source_utils.ipynb #su-check-audio-exists
def check_audio_exists(
    media_path: str  # Path to audio file
) -> bool:  # True if file exists
    """Check if the audio file exists at the given path."""
    if not media_path or media_path == "Unknown":
        return False
    return Path(media_path).exists()

# %% ../../nbs/services/source_utils.ipynb #su-validate-browse-path
def validate_browse_path(
    path: str  # Path to validate
) -> str:  # Validated and resolved path, or home directory on error
    """Validate a browse path for security. Returns home directory on invalid input."""
    try:
        resolved = Path(path).resolve()
        if resolved.exists() and resolved.is_dir():
            return str(resolved)
    except (ValueError, OSError):
        pass
    return str(Path.home())
